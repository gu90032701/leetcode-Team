# Rule

1. 分解问题的角度: fix 某一维度，尝试另一维度上的所有可能
   a. 可能是array的(i, j)pointers, b. 可能是矩形的长与宽, c. 可能是tree的每一个subtree, d. 可能是情景题的每一对pair...
2. 求所有解的, 暴力上backtracking吧
3. 如果问最短/最少的, 先想BFS、DP这对好基友
4. 如果环相关/重复访问, DFS + visited state雄起
5. 如果问连通性, 静态靠DFS/BFS, 动态靠Union-Find
6. 如果有依赖性, 想想Topologic order 和indegree
7. DAG的万能套路 DFS+memo, 再到DP
8. 建图的时候想想vertex, edges/neighbors, cost分别是什么。如果出现cycle, 别忘了给vertex增加状态
9. 树相关, 永远有backtracking 和 pure recursion两条路
10. 遇到字符串/字典/char board相关的, Trie tree总是可以试试的
11. Range里求最大/最小/sum等特征值, Segment tree会是不错的选择
12. Matrix和Array通常都是1. Two Pointers, 2. Sliding Window(fixed & not fixed), 3. DP
13. DP题型往往是: a. 问你可不可以啊, 数量有多少啊, b. 两个string上match来match去的, c. 1D/2D array 相关, d. 博弈游戏
14. 破解DAG cycle想想哪个维度是具有单调性的: 常见的steps, directions, paths
15. Reversed idea非常重要, 可能会帮助你破题: 最长可能是某种最短的反面, 最多可能是某种最少的反面, obstacle的反面是reachable, subarray的反面是array中的剩下元素, left的反面是right。
16. Look up别忘了HashMap/HashSet, HashMap + DLL是常见hybrid数据结构。
17. 找规律试试那些旁门左道: 单调Stack/双端Deque
18. 排序大法总是可以试试的
19. 时空复杂度: a. backtracking相关, 想想branching factor和height
                         b. DFS+memo/DP相关, 想想state数量, 以及每个state的cost
                         c. tree相关, 总是要考虑balanced 和 single linked list的
                         d. array/矩阵相关, 先数数你有多少个for loops
                         e. binary search application相关, 别忘了check function开销
                         f. stack/queue/deque相关, 常说的吃进去一次又吐出来一次
                         g. Java的string是朵奇葩, string concatenation不是免费的
                         h. 没人知道n是什么, 先告诉别人m，n，k，V，E是什么
20. 比较不同sol的trade offs: a. Time/Space complexity异同
                                             b. online/offline算法
                                             c. pre-computation cost
                                             d. 不同APIs的call frequency差异会导致不同的时间要求
                                             e. extension: 是否适用于generic parameters/stream input
                                             f. 线程安全/large scale

DP

- First, the problem asks us to **maximize** some value (the number of coins we can collect). 
- Second, each decision that we make at depends on previously made decisions
  - Top-Down DP, also known as Memoization DP, uses recursive function and memoization.
  - Bottom-Up DP, also known as Tabulation DP, uses iteration and DP array.	

```
function dp(dp_state, memo_dict) {
    // check if we have seen this dp_state
    if dp_state in memo_dict
        return memo_dict[dp_state]

    // base case (a case that we know the answer for already) such as dp_state is empty
    if dp_state is the base cases
        return things like 0 or null
    
    calculate dp(dp_state) from dp(other_state)
    
    save dp_state and the result into memo_dict
}
function answerToProblem(input) {
    return dp(start_state, empty_memo_dict)
}
```



# Dynamic Programming

[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching)

```
enum Result {
    TRUE, FALSE
}

class Solution {
    Result[][] memo;

    public boolean isMatch(String text, String pattern) {
        memo = new Result[text.length() + 1][pattern.length() + 1];
        return dp(0, 0, text, pattern);
    }

    public boolean dp(int i, int j, String text, String pattern) {
        if (memo[i][j] != null) {
            return memo[i][j] == Result.TRUE;
        }
        boolean ans;
        if (j == pattern.length()){
            ans = i == text.length();
        } else{
            boolean first_match = (i < text.length() &&
                                   (pattern.charAt(j) == text.charAt(i) ||
                                    pattern.charAt(j) == '.'));

            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){
                ans = (dp(i, j+2, text, pattern) ||
                       first_match && dp(i+1, j, text, pattern));
            } else {
                ans = first_match && dp(i+1, j+1, text, pattern);
            }
        }
        memo[i][j] = ans ? Result.TRUE : Result.FALSE;
        return ans;
    }
}
```

[312. Burst Balloons](https://leetcode.com/problems/burst-balloons)

```
class Solution {
    public int maxCoins(int[] nums) {
        // add 1 before and after nums
        int n = nums.length + 2;
        int[] newNums = new int[n];
        System.arraycopy(nums, 0, newNums, 1, n - 2);
        newNums[0] = 1;
        newNums[n - 1] = 1;

        // cache the results of dp
        int[][] memo = new int[n][n];

        // we can not burst the first one and the last one
        // since they are both fake balloons added by ourselves
        return dp(memo, newNums, 1, n - 2);
    }

    public int dp(int[][] memo, int[] nums, int left, int right) {
        // return maximum if we burst all nums[left]...nums[right], inclusive
        if (right - left < 0) {
            return 0;
        }

        // we've already seen this, return from cache
        if (memo[left][right] > 0) {
            return memo[left][right];
        }

        // find the last burst one in nums[left]...nums[right]
        int result = 0;
        for (int i = left; i <= right; i++) {
            // nums[i] is the last burst one
            int gain = nums[left - 1] * nums[i] * nums[right + 1];
            // nums[i] is fixed, recursively call left side and right side
            int remaining = dp(memo, nums, left, i - 1) + dp(memo, nums, i + 1, right);
            result = Math.max(result, remaining + gain);
        }
        // add to the cache
        memo[left][right] = result;
        return result;
    }
}
```



# Straight forward

[791. Custom Sort String](https://leetcode.com/problems/custom-sort-string)

```
class Solution {
    public String customSortString(String S, String T) {
        // count[char] = the number of occurrences of 'char' in T.
        // This is offset so that count[0] = occurrences of 'a', etc.
        // 'count' represents the current state of characters
        // (with multiplicity) we need to write to our answer.
        int[] count = new int[26];
        for (char c: T.toCharArray())
            count[c - 'a']++;

        // ans will be our final answer.  We use StringBuilder to join
        // the answer so that we more efficiently calculate a
        // concatenation of strings.
        StringBuilder ans = new StringBuilder();

        // Write all characters that occur in S, in the order of S.
        for (char c: S.toCharArray()) {
            for (int i = 0; i < count[c - 'a']; ++i)
                ans.append(c);
            // Setting count[char] to zero to denote that we do
            // not need to write 'char' into our answer anymore.
            count[c - 'a'] = 0;
        }

        // Write all remaining characters that don't occur in S.
        // That information is specified by 'count'.
        for (char c = 'a'; c <= 'z'; ++c)
            for (int i = 0; i < count[c - 'a']; ++i)
                ans.append(c);

        return ans.toString();
    }
}

```



[1288. Remove Covered Intervals](https://leetcode.com/problems/remove-covered-intervals)

```
class Solution {
  public int removeCoveredIntervals(int[][] intervals) {
    Arrays.sort(intervals, new Comparator<int[]>() {
      @Override
      public int compare(int[] o1, int[] o2) {
        // Sort by start point.
        // If two intervals share the same start point,
        // put the longer one to be the first.
        return o1[0] == o2[0] ? o2[1] - o1[1]: o1[0] - o2[0];
      }
    });

    int count = 0;
    int end, prev_end = 0;
    for (int[] curr : intervals) {
      end = curr[1];
      // if current interval is not covered
      // by the previous one
      if (prev_end < end) {
        ++count;
        prev_end = end;
      }
    }
    return count;
  }
}
```



# Two pointer

[408. Valid Word Abbreviation](https://leetcode.com/problems/valid-word-abbreviation) 

Input: "s10n"` == (`"s ubstitutio n"`)

return True / False

```
class Solution {
    public boolean validWordAbbreviation(String word, String abbr) {
        // Always pointing to previous character that was matched, initiating as -1
        int wIndex = -1;
        // Keep track of the count of chars being abbreviated
        int count = 0;
        
        for (char c : abbr.toCharArray()) {
            // Compare the the current letter in abbr with the char at the index determined below
            if (Character.isLetter(c)) {
                // The next char in word to match with c is 
                // the previously matched position, plus 1, plus the # of abbreviated chars in the middle
                wIndex = wIndex + count + 1; 
                if (wIndex >= word.length() || word.charAt(wIndex) != c) return false;
                // Reset count to 0 after match
                count = 0;
            } else {
                // No leading 0 allowed
                if (c == '0' && count == 0) return false;
                // If c is digit, we simply update the count for matching later
                count = count * 10 + (c - '0');
            }
        }
        // If the abbr ends with a number, count should equal to the remaining # of chars in word that are unmatched
        return count = word.length() - 1 - wIndex;
    }
}
```

[21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists)

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        
        ListNode chain = new ListNode();
        ListNode current = chain;
        while(list1 != null || list2 != null){
            if(list1 != null && list2 != null){
                
                if(list1.val<= list2.val){
                    current.next =  list1;
                    list1 = list1.next;
                } else {
                    current.next = list2;
                    list2 = list2.next;
                }
                
         //       ?  : ;
                current = current.next;
            } else if (list1 != null){
                current.next = list1;
                break;          
                
            } else {
                current.next = list2;
                break;
            
            }
        }
        
        return chain.next;
        
    }
}
```





## Two point variation



[1010. Pairs of Songs With Total Durations Divisible by 60](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60)

```
class Solution {
    public int numPairsDivisibleBy60(int[] time) {
        int remainders[] = new int[60];
        int count = 0;
        for (int t: time) {
            if (t % 60 == 0) { // check if a%60==0 && b%60==0
                count += remainders[0];
            } else { // check if a%60+b%60==60
                count += remainders[60 - t % 60];
            }
            remainders[t % 60]++; // remember to update the remainders
        }
        return count;
    }
}
```



# String dimension

[9. Palindrome Number](https://leetcode.com/problems/palindrome-number)

```
class Solution {
    public boolean isPalindrome(int x) {
        
        String number = String.valueOf(x);
        int length = number.length();
        for(int i = 0; i < length / 2; i++){
            if(number.charAt(i) != number.charAt(length - 1 - i))
                return false;
        }
        
        return true;
    }
}
```



# Tree

[160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists)

```
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> nodesInB = new HashSet<ListNode>();

        while (headB != null) {
            nodesInB.add(headB);
            headB = headB.next;
        }

        while (headA != null) {
            // if we find the node pointed to by headA,
            // in our set containing nodes of B, then return the node
            if (nodesInB.contains(headA)) {
                return headA;
            }
            headA = headA.next;
        }

        return null;
    }
}
```

[1650. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii)

```
class Solution {
    public Node lowestCommonAncestor(Node p, Node q) {
        List<Node> path = find_Path(p);
        while (q.parent != null) {
            for (Node node : path) {
                if (node == q) return q;
            }
            q = q.parent;
        }
        return q;
    }
    
    public List<Node> find_Path(Node p) {
        List<Node> path = new ArrayList<>();
        while (p.parent != null) {
            path.add(p);
            p = p.parent;
        }
        return path;
    }
}
```

Optimize

```
public Node lowestCommonAncestor(Node p, Node q) {
     Node p1 = p, p2 = q;
	 while (p1 != p2) {
		 p1 = p1 == null ? q : p1.parent;
		 p2 = p2 == null ? p : p2.parent;    
	  }
	  return p1;
}
```

[987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree)

DFS BFS

```
class Solution {
    
    // Map<Index, TreeMap<level, node.val>>
    Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map;
    
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        if (root == null)
            return null;
        map = new TreeMap<>();
        dfs(root, 0, 0);
        List<List<Integer>> res = new LinkedList<>();
        for (int key : map.keySet()){
            List<Integer> list = new LinkedList<>();
            TreeMap<Integer, PriorityQueue<Integer>> tm = map.get(key);
            for (int k : tm.keySet()){
                PriorityQueue<Integer> pq = tm.get(k);
                while (!pq.isEmpty()){
                    list.add(pq.poll());
                }
            }
            res.add(list);
        }
        return res;
    }
    
    private void dfs(TreeNode root, int index, int level){
        if (root == null)
            return;
        
        map.putIfAbsent(index, new TreeMap<>());
        map.get(index).putIfAbsent(level, new PriorityQueue<>());
        map.get(index).get(level).add(root.val);
        dfs(root.left, index - 1, level + 1);
        dfs(root.right, index + 1, level + 1);
    }
}
```

[212. Word Search II](https://leetcode.com/problems/word-search-ii)

Trie

```
class TrieNode {
  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
  String word = null;
  public TrieNode() {}
}

class Solution {
  char[][] _board = null;
  ArrayList<String> _result = new ArrayList<String>();

  public List<String> findWords(char[][] board, String[] words) {

    // Step 1). Construct the Trie
    TrieNode root = new TrieNode();
    for (String word : words) {
      TrieNode node = root;

      for (Character letter : word.toCharArray()) {
        if (node.children.containsKey(letter)) {
          node = node.children.get(letter);
        } else {
          TrieNode newNode = new TrieNode();
          node.children.put(letter, newNode);
          node = newNode;
        }
      }
      node.word = word;  // store words in Trie
    }

    this._board = board;
    // Step 2). Backtracking starting for each cell in the board
    for (int row = 0; row < board.length; ++row) {
      for (int col = 0; col < board[row].length; ++col) {
        if (root.children.containsKey(board[row][col])) {
          backtracking(row, col, root);
        }
      }
    }

    return this._result;
  }
  
  private void backtracking(int row, int col, TrieNode parent) {
    Character letter = this._board[row][col];
    TrieNode currNode = parent.children.get(letter);

    // check if there is any match
    if (currNode.word != null) {
      this._result.add(currNode.word);
      currNode.word = null;
    }

    // mark the current letter before the EXPLORATION
    this._board[row][col] = '#';

    // explore neighbor cells in around-clock directions: up, right, down, left
    int[] rowOffset = {-1, 0, 1, 0};
    int[] colOffset = {0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
      int newRow = row + rowOffset[i];
      int newCol = col + colOffset[i];
      if (newRow < 0 || newRow >= this._board.length || newCol < 0
          || newCol >= this._board[0].length) {
        continue;
      }
      if (currNode.children.containsKey(this._board[newRow][newCol])) {
        backtracking(newRow, newCol, currNode);
      }
    }

    // End of EXPLORATION, restore the original letter in the board.
    this._board[row][col] = letter;

    // Optimization: incrementally remove the leaf nodes
    if (currNode.children.isEmpty()) {
      parent.children.remove(letter);
    }
  }
}

```



[987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree)



```
class Solution {
    class Node {
        int row;
        int val;
        Node(int row, int val) {
            this.row = row;
            this.val = val;
        }
    }
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        TreeMap<Integer, Queue<Node>> map = new TreeMap<>();
        helper(root, map, 0, 0);
        
        List<List<Integer>> ret = new ArrayList<>();
        for (int c : map.keySet()) {
            List<Integer> list = new ArrayList<>();
            ret.add(list);
            Queue<Node> q = map.get(c);
            while (!q.isEmpty()) {
                list.add(q.poll().val);
            }
        }
        return ret;
    }
    
    private void helper(TreeNode cur, TreeMap<Integer, Queue<Node>> map, int r, int c) {
        if (cur == null) return;
        map.putIfAbsent(c, new PriorityQueue<Node>((a, b) -> a.row != b.row ? a.row - b.row : a.val - b.val));
        map.get(c).add(new Node(r, cur.val));
        helper(cur.left, map, r + 1, c - 1);
        helper(cur.right, map, r + 1, c + 1);
    }
}
```

$$
 H_{in}, W_{in}, C_{in}, m

\\

[\dfrac{H_{in}}{2} \times
\dfrac{W_{in}}{2} \times C_{in} \times m]

\\

[\frac{H_{in}}{2} \times \frac{W_{in}}{2} \times C_{in} \times m]
$$

## BFS + DFS

[863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree)

```
class Solution {
    Map<TreeNode, TreeNode> parent;
    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        parent = new HashMap();
        dfs(root, null);

        Queue<TreeNode> queue = new LinkedList();
        queue.add(null);
        queue.add(target);

        Set<TreeNode> seen = new HashSet();
        seen.add(target);
        seen.add(null);

        int dist = 0;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                if (dist == K) {
                    List<Integer> ans = new ArrayList();
                    for (TreeNode n: queue)
                        ans.add(n.val);
                    return ans;
                }
                queue.offer(null);
                dist++;
            } else {
                if (!seen.contains(node.left)) {
                    seen.add(node.left);
                    queue.offer(node.left);
                }
                if (!seen.contains(node.right)) {
                    seen.add(node.right);
                    queue.offer(node.right);
                }
                TreeNode par = parent.get(node);
                if (!seen.contains(par)) {
                    seen.add(par);
                    queue.offer(par);
                }
            }
        }

        return new ArrayList<Integer>();
    }

    public void dfs(TreeNode node, TreeNode par) {
        if (node != null) {
            parent.put(node, par);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    }
}
```



# Stack

[921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid)



```
class Solution {
    public int minAddToMakeValid(String S) {
        int ans = 0, bal = 0;
        for (int i = 0; i < S.length(); ++i) {
            bal += S.charAt(i) == '(' ? 1 : -1;
            // It is guaranteed bal >= -1
            if (bal == -1) {
                ans++;
                bal++;
            }
        }

        return ans + bal;
    }
}
```





[2104. Sum of Subarray Ranges](https://leetcode.com/problems/sum-of-subarray-ranges)

```
https://leetcode.com/problems/sum-of-subarray-ranges/discuss/2059690/Java-3-Solutions-with-Explanation-or-Monotonic-Stack-or-O(n)
```



# HashMap

[692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words)

```
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        HashMap<String,Integer> freq=new HashMap<>();
        for(int i=0;i<words.length;i++)
        {
            freq.put(words[i],freq.getOrDefault(words[i],0)+1);
        }
        List<String> res = new ArrayList(freq.keySet());
        //sorting
        //if two words have the same frequency, then the word with the lower alphabetical order comes first.
        //else most frequent words will come first
        Collections.sort(res, (w1, w2) -> freq.get(w1).equals(freq.get(w2)) ?
                w1.compareTo(w2) : freq.get(w2) - freq.get(w1));

        return res.subList(0, k);
    }
}
```

# Linked List

[9. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list)

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int length = 0;
        ListNode start = head;
        ListNode finalResult = new ListNode(0);
        finalResult.next = head;
        while(head.next != null){
            length += 1;
            head = head.next;
        }
        int stop = length - n;
        
        start = finalResult;
        while (stop >= 0){
            
            stop--;
            start = start.next;
        }
        if(start  == null){
            return null;
        }
        start.next = start.next.next;
        return finalResult.next;
    }
}
```





Two Sum





# Workshop

SDE 1 -> Assisting role

- Work with other

SDE 2 -> Own service, Expert

- 

SDE 3 -> Expected to be on team level. Own everything. Feature, end to end. Point of contact



![image-20220526113652018](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526113652018.png)



## System Design

SDE 1: 0  session

SDE 2: 1 session

SDE 3: 2 session  (deal breaker)

Coding bar isn't obvious. System design, big jump

Key points

- Ambiguity (Key)
  - Clarify critical function requirement

- Comprehensive
- Abstraction and boundary
- Scaling
  - 1 billion event per day, make sure no down time
- Staying on the track
- Alternatives
  - Compared 
- Avoidable mistakes
- Details

### Examples

![image-20220526114427210](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526114427210.png)

![image-20220526115011124](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526115011124.png)



Shorten url functional requirement

- How short it could be
- What is the charSet? Different charset to support use case
  - Only support English, different utf-16
- Could the long url be deleted in future

Non functional

Scalable, high available



Write one, Read many times

- Make the read really fast, trade off on the write

Short url

- Backend will return long one, Http 302, 
- In memory, persisted. Pros & Cons
- Hash, SHA, multiple string mapped to same hash value (fixed length) -> Collision Control
- Human understandable string, conversion
  - Change encoding, Base64 conversion-> 26 character + 10 digits



### Book

![image-20220526120124729](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526120124729.png)





## Coding

![image-20220526120154605](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526120154605.png)

![image-20220526120441742](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526120441742.png)

> Not specific domain knowledge like socket
>
> Java shop

- Translate idea into workable code
- Identitfy different solutions and evaluate them
- Break down into smaller piece to slove
- Dealing with ambiguity
- Know variety of known structures
  - Heap, LinkedList
- Time complexity
- Know how DS work internally
  - Red black tree
- Identity edge cases
- Design pattern

## Preparation

- Be confident

- Practice (Not in IDE)
- Common data structure
- Common design pattern

## Common Mistakes

![image-20220526121649726](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526121649726.png)

- No clarification questions
- Jump into implementation too quick
- No think out loud

![image-20220526121633509](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526121633509.png)

> 3 coding, 1 LP (full LP related problem), 1 OOD (optional)

SDE 3 should be able to lead the discussion, define the scope of the whole process

# Leadership Principle

![image-20220526123329055](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526123329055.png)

8 - 10 examples

![image-20220526123844248](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526123844248.png)

> What did you do.

## STAR

![image-20220526124003667](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526124003667.png)





## 41 Amazon

△ 23次

### [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) 中等

![image-20220526234640319](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220526234640319.png)

△ 21次

### [146. LRU Cache](https://leetcode.com/problems/lru-cache/) 中等 :star:

△ 19次

```
public class LRUCache {

  class DLinkedNode {
    int key;
    int value;
    DLinkedNode prev;
    DLinkedNode next;
  }

  private void addNode(DLinkedNode node) {
    /**
     * Always add the new node right after head.
     */
    node.prev = head;
    node.next = head.next;

    head.next.prev = node;
    head.next = node;
  }

  private void removeNode(DLinkedNode node){
    /**
     * Remove an existing node from the linked list.
     */
    DLinkedNode prev = node.prev;
    DLinkedNode next = node.next;

    prev.next = next;
    next.prev = prev;
  }

  private void moveToHead(DLinkedNode node){
    /**
     * Move certain node in between to the head.
     */
    removeNode(node);
    addNode(node);
  }

  private DLinkedNode popTail() {
    /**
     * Pop the current tail.
     */
    DLinkedNode res = tail.prev;
    removeNode(res);
    return res;
  }

  private Map<Integer, DLinkedNode> cache = new HashMap<>();
  private int size;
  private int capacity;
  private DLinkedNode head, tail;

  public LRUCache(int capacity) {
    this.size = 0;
    this.capacity = capacity;

    head = new DLinkedNode();
    // head.prev = null;

    tail = new DLinkedNode();
    // tail.next = null;

    head.next = tail;
    tail.prev = head;
  }

  public int get(int key) {
    DLinkedNode node = cache.get(key);
    if (node == null) return -1;

    // move the accessed node to the head;
    moveToHead(node);

    return node.value;
  }

  public void put(int key, int value) {
    DLinkedNode node = cache.get(key);

    if(node == null) {
      DLinkedNode newNode = new DLinkedNode();
      newNode.key = key;
      newNode.value = value;

      cache.put(key, newNode);
      addNode(newNode);

      ++size;

      if(size > capacity) {
        // pop the tail
        DLinkedNode tail = popTail();
        cache.remove(tail.key);
        --size;
      }
    } else {
      // update the value.
      node.value = value;
      moveToHead(node);
    }
  }
}
```



### [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/) 中等

> Using Array to store frequency

△ 19次

```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        
        Map<String , List<String>> result = new HashMap<>();
        for(String str : strs){
            int [] array = new int [26];
            for(char c : str.toCharArray()){
                array[c - 'a'] += 1;
            }
            
            String key = Arrays.toString(array);
            
            if(result.get(key) == null){
                List<String> newList = new ArrayList<>();
                newList.add(str);
                result.put(key, newList);
            } else {
                List<String> temp = result.get(key);
                temp.add(str);
                result.put(key, temp);
            }
            
        }
        
        List<List<String>> finalResult = new ArrayList<>();
        
        for(String  i : result.keySet()){
            finalResult.add(result.get(i));
        }
        
        return finalResult;
    }
}
```



### [116. Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) 中等

> BFS, with condition (stop at each level)

△ 18次

```
class Solution {
    public Node connect(Node root) {
        
         if (root == null) {
            return root;
        }
        Queue<Node> queue = new LinkedList<>();
        
        queue.add(root);
    
      
        
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                 Node current = queue.poll();
                
                   if(i < size - 1){
                        current.next = queue.peek();
                  }
                
                if(current.left != null){
                    queue.add(current.left);
                }
                 if(current.right != null){
                    queue.add(current.right);
                }
                
            }
            
        }
        
        return root;
    }
}
```



### [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) 中等

> Traditional DFS, Need memorize

```java
class Solution {
    
    
    public void dfs(char[][] grid, int row, int col){
        
        int colLength = grid[0].length;
        if(row < 0 || row >= grid.length || col < 0 || col >= colLength || grid[row][col] == '0'){
            return;
        }
        
        grid[row][col] = '0';
        
        dfs(grid, row + 1, col);
        dfs(grid, row - 1, col);
        dfs(grid, row , col + 1);
        dfs(grid, row , col - 1);
    }
    
    
    public int numIslands(char[][] grid) {
        
        int island = 0;
        int colLength = grid[0].length;
        for(int i = 0; i < grid.length;i++){
            for(int j = 0; j < colLength;j++){
                if(grid[i][j] == '1'){
                    island++;
                    dfs(grid, i, j);
                }
            }
        }
        
        return island;
    }
}
```

> BFS

> Union Find

△ 16次

### 207Course Schedule

```
class Solution {
  public boolean canFinish(int numCourses, int[][] prerequisites) {

    // course -> list of next courses
    HashMap<Integer, List<Integer>> courseDict = new HashMap<>();

    // build the graph first
    for (int[] relation : prerequisites) {
      // relation[0] depends on relation[1]
      if (courseDict.containsKey(relation[1])) {
        courseDict.get(relation[1]).add(relation[0]);
      } else {
        List<Integer> nextCourses = new LinkedList<>();
        nextCourses.add(relation[0]);
        courseDict.put(relation[1], nextCourses);
      }
    }

    boolean[] path = new boolean[numCourses];

    for (int currCourse = 0; currCourse < numCourses; ++currCourse) {
      if (this.isCyclic(currCourse, courseDict, path)) {
        return false;
      }
    }

    return true;
  }


  /*
   * backtracking method to check that no cycle would be formed starting from currCourse
   */
  protected boolean isCyclic(
      Integer currCourse,
      HashMap<Integer, List<Integer>> courseDict,
      boolean[] path) {

    if (path[currCourse]) {
      // come across a previously visited node, i.e. detect the cycle
      return true;
    }

    // no following courses, no loop.
    if (!courseDict.containsKey(currCourse))
      return false;

    // before backtracking, mark the node in the path
    path[currCourse] = true;

    // backtracking
    boolean ret = false;
    for (Integer nextCourse : courseDict.get(currCourse)) {
      ret = this.isCyclic(nextCourse, courseDict, path);
      if (ret)
        break;
    }
    // after backtracking, remove the node from the path
    path[currCourse] = false;
    return ret;
  }
}
```



### [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) 中等 :star:

> Topological sort

△ 16次

```
public class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        //prepare
        List<List<Integer>> graph = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            graph.add(new ArrayList<>());
        }

        for(int[] pair : prerequisites){
            int prev = pair[1];
            int next = pair[0];
            graph.get(prev).add(next);
        }

        Map<Integer, Integer> visited = new HashMap<>();
        //initail visited
        for(int i = 0; i < numCourses; i++){
            visited.put(i, 0);//0 -> unvisited, 1 -> visiting, 2 -> visited
        }

        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            if(!topoSort(res, graph, visited, i)) return new int[0];
        }

        int[] result = new int[numCourses];
        for(int i = 0; i < numCourses; i++){
            result[i] = res.get(numCourses - i - 1);
        }
        return result;
    }

    //the return value of this function only contains the ifCycle info and does not interfere dfs process. if there is Cycle, then return false
    private boolean topoSort(List<Integer> res, List<List<Integer>> graph, Map<Integer, Integer> visited, int i){
        int visit = visited.get(i);
        if(visit == 2){//when visit = 2, which means the subtree whose root is i has been dfs traversed and all the nodes in subtree has been put in the result(if we request), so we do not need to traverse it again
            return true;  
        }if(visit == 1){
            return false;
        }

        visited.put(i, 1);
        for(int j : graph.get(i)){
            if(!topoSort(res, graph, visited, j)) return false;
        }
        visited.put(i, 2);
        res.add(i);//the only difference with traversing a graph

        return true;
    }
}
```



### [48. Rotate Image](https://leetcode.com/problems/rotate-image/) 中等

> Rotation on symetric

> ```java
> public void rotate(int[][] matrix) {
>     int n = matrix.length;
>     for (int i = 0; i < (n + 1) / 2; i ++) {
>         for (int j = 0; j < n / 2; j++) {
>             int temp = matrix[n - 1 - j][i];
>             matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
>             matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
>             matrix[j][n - 1 - i] = matrix[i][j];
>             matrix[i][j] = temp;
>         }
>     }
> }
> ```

△ 15次

### [151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/) 中等

> Regular expression
>
> ```java
> class Solution {
>     public String reverseWords(String s) {
>         s = s.trim();
>         String [] strs = s.split("\\s+");
>         String result = "";
>         for(int i = strs.length - 1; i > 0 ; i--){
>             result += strs[i];
>             result += " ";
>         }
> 
>             result += strs[0];
>       
>         
>         return result;
>     }
> }
> ```
>
> 

△ 15次

### [126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/) 困难 :star:

> Combination of back track, BFS, 

### [127. Word Ladder](https://leetcode.com/problems/word-ladder) :star:

> BFS

△ 14次

### [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) 中等

> Sort the interval, then do the comparsion

△ 14次

### [322. Coin Change](https://leetcode.com/problems/coin-change/) 中等

> DP top down, botton up

△ 14次

```
public class Solution {

  public int coinChange(int[] coins, int amount) {
    if (amount < 1) return 0;
    return coinChange(coins, amount, new int[amount]);
  }

  private int coinChange(int[] coins, int rem, int[] count) {
    if (rem < 0) return -1;
    if (rem == 0) return 0;
    if (count[rem - 1] != 0) return count[rem - 1];
    int min = Integer.MAX_VALUE;
    for (int coin : coins) {
      int res = coinChange(coins, rem - coin, count);
      if (res >= 0 && res < min)
        min = 1 + res;
    }
    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
    return count[rem - 1];
  }
}
```

### Meeting room

```
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        for (int i = 0; i < intervals.length; i++) {
            for (int j = i + 1; j < intervals.length; j++) {
                if (overlap(intervals[i], intervals[j])) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean overlap(int[] interval1, int[] interval2) {
        return (interval1[0] >= interval2[0] && interval1[0] < interval2[1])
            || (interval2[0] >= interval1[0] && interval2[0] < interval1[1]);
    }
}
```



### [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) 中等

> Min Queue

△ 14次

```
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        
    // Check for the base case. If there are no intervals, return 0
    if (intervals.length == 0) {
      return 0;
    }

    // Min heap
    PriorityQueue<Integer> allocator =
        new PriorityQueue<Integer>(
            intervals.length,
            new Comparator<Integer>() {
              public int compare(Integer a, Integer b) {
                return a - b;
              }
            });

    // Sort the intervals by start time
    Arrays.sort(
        intervals,
        new Comparator<int[]>() {
          public int compare(final int[] a, final int[] b) {
            return a[0] - b[0];
          }
        });
        
        
 //[0,30],[5,10],[15,20]]  
        
//30

    // Add the first meeting
    allocator.add(intervals[0][1]);

    // Iterate over remaining intervals
    for (int i = 1; i < intervals.length; i++) {

      // If the room due to free up the earliest is free, assign that room to this meeting.
      if (intervals[i][0] >= allocator.peek()) {
        allocator.poll();
      }

      // If a new room is to be assigned, then also we add to the heap,
      // If an old room is allocated, then also we have to add to the heap with updated end time.
      allocator.add(intervals[i][1]);
    }

    // The size of the heap tells us the minimum rooms required for all the meetings.
    return allocator.size();
  }
}
```



### [445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/) 中等

> Reverse list
>
> ```
>     public ListNode reverseList(ListNode head) {
>         ListNode last = null;
>         while (head != null) {
>             // keep the next node
>             ListNode tmp = head.next;
>             // reverse the link
>             head.next = last;
>             // update the last node and the current node
>             last = head;
>             head = tmp;    
>         }    
>         return last;
>     }
> ```
>
> Stack

△ 14次

### DP  [472. Concatenated Words](https://leetcode.com/problems/concatenated-words/) 困难

> DP bottom up

△ 14次

[381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/) 困难

△ 14次

[238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) 中等

△ 12次

[99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/) 中等

△ 12次

[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) 简单

△ 12次

[240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) 中等

△ 12次

[47. Permutations II](https://leetcode.com/problems/permutations-ii/) 中等

△ 11次

[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/) 中等

△ 11次

[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/) 中等

△ 10次

[212. Word Search II](https://leetcode.com/problems/word-search-ii/) 困难

△ 7次

[937. Reorder Data in Log Files](https://leetcode.com/problems/reorder-data-in-log-files/) 简单

△ 6次

### [224. Basic Calculator](https://leetcode.com/problems/basic-calculator/) 困难

> Use of stack

```
class Solution {
    public int calculate(String s) {

        Stack<Integer> stack = new Stack<Integer>();
        int operand = 0;
        int result = 0; // For the on-going result
        int sign = 1;  // 1 means positive, -1 means negative

        for (int i = 0; i < s.length(); i++) {

            char ch = s.charAt(i);
            if (Character.isDigit(ch)) {

                // Forming operand, since it could be more than one digit
                operand = 10 * operand + (int) (ch - '0');

            } else if (ch == '+') {

                // Evaluate the expression to the left,
                // with result, sign, operand
                result += sign * operand;

                // Save the recently encountered '+' sign
                sign = 1;

                // Reset operand
                operand = 0;

            } else if (ch == '-') {

                result += sign * operand;
                sign = -1;
                operand = 0;

            } else if (ch == '(') {

                // Push the result and sign on to the stack, for later
                // We push the result first, then sign
                stack.push(result);
                stack.push(sign);

                // Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1;
                result = 0;

            } else if (ch == ')') {

                // Evaluate the expression to the left
                // with result, sign and operand
                result += sign * operand;

                // ')' marks end of expression within a set of parenthesis
                // Its result is multiplied with sign on top of stack
                // as stack.pop() is the sign before the parenthesis
                result *= stack.pop();

                // Then add to the next operand on the top.
                // as stack.pop() is the result calculated before this parenthesis
                // (operand on stack) + (sign on stack * (result from parenthesis))
                result += stack.pop();

                // Reset the operand
                operand = 0;
            }
        }
        return result + (sign * operand);
    }
}
```

△ 6次

[17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) 中等

△ 6次

[692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/) 中等

△ 6次

[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) 困难

△ 4次

[295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) 困难

△ 4次

[348. Design Tic-Tac-Toe](https://leetcode.com/problems/design-tic-tac-toe/) 中等

△ 3次

[799. Champagne Tower](https://leetcode.com/problems/champagne-tower/) 中等

△ 3次

[387. First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/) 简单

△ 3次

[155. Min Stack](https://leetcode.com/problems/min-stack/) 简单

△ 2次

[140. Word Break II](https://leetcode.com/problems/word-break-ii/) 困难

△ 2次

[828. Count Unique Characters of All Substrings of a Given String](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 困难



## Amazon top Question



[103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)

[210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii)

[348. Design Tic-Tac-Toe](https://leetcode.com/problems/design-tic-tac-toe)

[370. Range Addition](https://leetcode.com/problems/range-addition)

discrete signal processing logic

[545. Boundary of Binary Tree](https://leetcode.com/problems/boundary-of-binary-tree)

The term "preorder traversal " was invented in 1726



people before 1726:

"We make use of a recursive function addLeaves(res,root), in which we change the root node for every recursive call. If the current root node happens to be a leaf node, it is added to the res array. Otherwise, we make the recursive call using the left child of the current node as the new root. After this, we make the recursive call using the right child of the current node as the new root."



## Mian Jing

 [103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)

Leetcode 200

 [55. Jump Game](https://leetcode.com/problems/jump-game)

Leetcode 146

[915. Partition Array into Disjoint Intervals](https://leetcode.com/problems/partition-array-into-disjoint-intervals)

[224. Basic Calculator](https://leetcode.com/problems/basic-calculator)

[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii)

##### Amazon Phone Interview - Valid Dictionary word from Phone Number

https://leetcode.com/discuss/interview-question/1012161/amazon-phone-interview-valid-dictionary-word-from-phone-number

[24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs)

https://en.wikipedia.org/wiki/Round-robin_scheduling



给一个class Region { String name, List<Region> subRegion} 给一个root region，让实现next（）功能，按顺序iterate每一个region里面的subregion name，注意subregion 还可能有自己的subregion，按照dfs的方式输出



sd：实现亚麻app里面的view order功能，用户点击view order以后显示最近50个order的product，timestamp，status。考虑高并发高可用，latency 200ms以下



给一个无cycle的tree，tree的每个node都有一个value，求cut一个edge使得新生成的两个subtree里面nod‍‍‌‍‍‍‍‌‍‌‍‍‌‍‍‍‍‌‌e value sum的分配最平均，最接近原来sum/2



top k elements



一个亚麻仓库，里面有很多不同种类货物，有点像parkinglot就是换了个皮。比较简单。多用多态，啥都用class来包装一下，然后最好写几个custom exception。



[115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences)

[450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst)

[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree)

[210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii)

[692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words)

Leetcode 253

[409. Longest Palindrome](https://leetcode.com/problems/longest-palindrome)

```
class Solution {
    public int longestPalindrome(String s) {
        int[] count = new int[128];
        for (char c: s.toCharArray())
            count[c]++;

        int ans = 0;
        for (int v: count) {
            ans += v / 2 * 2;
            if (ans % 2 == 0 && v % 2 == 1)
                ans++;
        }
        return ans;
    }
}
```

Union Find

[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists)

> Convert linked list to arrayList, then compare to last



```
//Given a char array, replace ‘ab’ to ‘c’  and replace ‘b’ to ‘ef’.
//It need you make the replacement on  the original array.
//We prefer you not use system API.
//Assumption： The occurrences of ‘ab’ must greater than or equal to  the occurrences of ‘b’.
```

```
//You are given two non-empty linked lists representing two non-negative integers.
// The digits are stored in reverse order, and each of their nodes contains a single digit.
```

### [146. LRU Cache](https://leetcode.com/problems/lru-cache)

### [127. Word Ladder](https://leetcode.com/problems/word-ladder)

BFS

```
class Solution {
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> set = new HashSet<>(wordList);
    Queue<String> queue = new LinkedList<>();
    queue.add(beginWord);
    // COUNT NUMBER OF WORDS TRANSFORMED
    int count = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        // FOR ALL WORDS THIS ROUND
        for (int i = 0; i < size; i++) {
            char[] current = queue.poll().toCharArray();
            // TRAVERSE CURRENT WORD
            for (int j = 0; j < current.length; j++) {
                char tmp = current[j];
                // CHANGE ONE LETTER AT A TIME 
                for (char c = 'a'; c <= 'z'; c++) {
                    current[j] = c;
                    String next = new String(current);
                    // WHEN NEXT WORD IS IN THE SET
                    if (set.contains(next)) {
                        if (next.equals(endWord)) return count + 1;
                        queue.add(next);
                        set.remove(next);
                    }
                }
                // HAVE TO UNDO FOR NEXT CHANGE OF LETTER
                current[j] = tmp;
            }
        }
        // THIS ROUND ENDS WITH ONE LETTER CHANGED
        count++;
    }
    return 0;
}
}
```





## June Mian Jing

Get next minimun number in multiple ordered streams

Smallest Range Covering Elements from K Lists

https://leetcode.com/problems/sm ... ments-from-k-lists/

```
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int minx = 0;
        int miny = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int[] next = new int[nums.size()];
        boolean flag = true;
        
        PriorityQueue <Integer> min_queue = new PriorityQueue <Integer> ((i, j) -> nums.get(i).get(next[i]) - nums.get(j).get(next[j]));
        for (int i = 0; i < nums.size(); i++) {
            min_queue.offer(i);
            max = Math.max(max, nums.get(i).get(0));
        }
        for (int i = 0; i < nums.size() && flag; i++) {
            for (int j = 0; j < nums.get(i).size() && flag; j++) {
                int min_i = min_queue.poll();
                if (miny - minx > max - nums.get(min_i).get(next[min_i])) {
                    minx = nums.get(min_i).get(next[min_i]);
                    miny = max;
                }
                next[min_i]++;
                if (next[min_i] == nums.get(min_i).size()) {
                    flag = false;
                    break;
                }
                min_queue.offer(min_i);
                max = Math.max(max, nums.get(min_i).get(next[min_i]));
            }
        }
        return new int[] { minx, miny};
    }
}
```



### First Unique Number

https://leetcode.com/problems/first-unique-number/

```
Queue and hashmap
class FirstUnique {

  private Queue<Integer> queue = new ArrayDeque<>();
  private Map<Integer, Boolean> isUnique = new HashMap<>();

  public FirstUnique(int[] nums) {
    for (int num : nums) {
      // Notice that we're calling the "add" method of FirstUnique; not of the queue. 
      this.add(num);
    }
  }

  public int showFirstUnique() {
    // We need to start by "cleaning" the queue of any non-uniques at the start.
    // Note that we know that if a value is in the queue, then it is also in
    // isUnique, as the implementation of add() guarantees this.
    while (!queue.isEmpty() && !isUnique.get(queue.peek())) {
      queue.remove();
    }
    // Check if there is still a value left in the queue. There might be no uniques.
    if (!queue.isEmpty()) {
      return queue.peek(); // We don't want to actually *remove* the value.
    }
    return -1;
  }

  public void add(int value) {
    // Case 1: We need to add the number to the queue and mark it as unique. 
    if (!isUnique.containsKey(value)) {
      isUnique.put(value, true);
      queue.add(value);
    // Case 2 and 3: We need to mark the number as no longer unique.
    } else {
      isUnique.put(value, false);
    }
  }
}
```



### Find Median from Data Stream

https://leetcode.com/problems/find-median-from-data-stream/

```
Sorted then find median, max min heap

class MedianFinder {
    // max queue is always larger or equal to min queue
    PriorityQueue<Integer> min = new PriorityQueue();
    PriorityQueue<Integer> max = new PriorityQueue(1000, Collections.reverseOrder());
    // Adds a number into the data structure.
    public void addNum(int num) {
        max.offer(num);
        min.offer(max.poll());
        if (max.size() < min.size()){
            max.offer(min.poll());
        }
    }

    // Returns the median of current data stream
    public double findMedian() {
        if (max.size() == min.size()) return (max.peek() + min.peek()) /  2.0;
        else return max.peek();
    }
};
```

23 Merge K Sorted Iterators （Merge k Sorted Lists）
https://link.1point3acres.com/?u ... -K-Sorted-Iterators
https://leetcode.com/problems/merge-k-sorted-lists/
找出前limit个最大的数
类似刷题网耳伞；具体描述是这样
有很多，很大的文件，找出前limit个最大的数

#### Course schedule II :star:

https://leetcode.com/problems/course-schedule-ii/

```
Topological sort, Indegree
```



Course Schedule
https://leetcode.com/problems/course-schedule/
Log 网页找最短路径
给你一个log含有网页redirect url，给你URL（a, b）问你能否从 a到b

```
class Solution {
  public boolean canFinish(int numCourses, int[][] prerequisites) {

    // course -> list of next courses
    HashMap<Integer, List<Integer>> courseDict = new HashMap<>();

    // build the graph first
    for (int[] relation : prerequisites) {
      // relation[0] depends on relation[1]
      if (courseDict.containsKey(relation[1])) {
        courseDict.get(relation[1]).add(relation[0]);
      } else {
        List<Integer> nextCourses = new LinkedList<>();
        nextCourses.add(relation[0]);
        courseDict.put(relation[1], nextCourses);
      }
    }

    boolean[] path = new boolean[numCourses];

    for (int currCourse = 0; currCourse < numCourses; ++currCourse) {
      if (this.isCyclic(currCourse, courseDict, path)) {
        return false;
      }
    }

    return true;
  }


  /*
   * backtracking method to check that no cycle would be formed starting from currCourse
   */
  protected boolean isCyclic(
      Integer currCourse,
      HashMap<Integer, List<Integer>> courseDict,
      boolean[] path) {

    if (path[currCourse]) {
      // come across a previously visited node, i.e. detect the cycle
      return true;
    }

    // no following courses, no loop.
    if (!courseDict.containsKey(currCourse))
      return false;

    // before backtracking, mark the node in the path
    path[currCourse] = true;

    // backtracking
    boolean ret = false;
    for (Integer nextCourse : courseDict.get(currCourse)) {
      ret = this.isCyclic(nextCourse, courseDict, path);
      if (ret)
        break;
    }
    // after backtracking, remove the node from the path
    path[currCourse] = false;
    return ret;
  }
}
```



Meeting Rooms II
https://leetcode.com/problems/meeting-rooms-ii/

```
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        
    // Check for the base case. If there are no intervals, return 0
    if (intervals.length == 0) {
      return 0;
    }

    // Min heap
    PriorityQueue<Integer> allocator =
        new PriorityQueue<Integer>(
            intervals.length,
            new Comparator<Integer>() {
              public int compare(Integer a, Integer b) {
                return a - b;
              }
            });

    // Sort the intervals by start time
    Arrays.sort(
        intervals,
        new Comparator<int[]>() {
          public int compare(final int[] a, final int[] b) {
            return a[0] - b[0];
          }
        });
        
        
 //[0,30],[5,10],[15,20]]  
        
//30

    // Add the first meeting
    allocator.add(intervals[0][1]);

    // Iterate over remaining intervals
    for (int i = 1; i < intervals.length; i++) {

      // If the room due to free up the earliest is free, assign that room to this meeting.
      if (intervals[i][0] >= allocator.peek()) {
        allocator.poll();
      }

      // If a new room is to be assigned, then also we add to the heap,
      // If an old room is allocated, then also we have to add to the heap with updated end time.
      allocator.add(intervals[i][1]);
    }

    // The size of the heap tells us the minimum rooms required for all the meetings.
    return allocator.size();
  }
}
```

### Build target string using baby blocks

https://link.1point3acres.com/?u ... ode.com%2Fdiscuss%2 Interview-question%2F923490%2Famazon-build-target-string-using-baby-blocks

```
// "static void main" must be defined in a public class.
public class Main {
    static class Pair {
        public char c1, c2;
        public boolean used = false;
        public Pair(char c1, char c2) {
            this.c1 = c1;
            this.c2 = c2;
        }
    }
    
    private static boolean bkt(String word, int i, Map<Character, Set<Pair>> map) {
        if (i == word.length()) return true;
        
        boolean valid = false;
        Set<Pair> pairs = map.get(word.charAt(i));
        if (pairs == null) return false;
        
        for (Pair p : pairs) {
            if (p.used == false) {
                p.used = true;
                valid = valid || bkt(word, i + 1, map);
                p.used = false;
            }
        }
            
        return valid;
    }
    
    public static boolean valid(String word, List<Pair> pairs) {
        Map<Character, Set<Pair>> map = new HashMap<>();
        for (Pair p : pairs) {
            map.computeIfAbsent(p.c1, k -> new HashSet<>()).add(p);
            map.computeIfAbsent(p.c2, k -> new HashSet<>()).add(p);
        }
        
        return bkt(word, 0, map);
    }
    
    public static void main(String[] args) {
        System.out.println("Baby=" + valid("baby", Arrays.asList(new Pair('b', 'a'), new Pair('a', 'b'), new Pair('b', 'c'), new Pair('x', 'y'), new Pair('e', 'f'))));
        
        System.out.println("Able=" + valid("able", Arrays.asList(new Pair('b', 'a'), new Pair('a', 'b'), new Pair('l', 'e'), new Pair('c', 'd'))));
    }
}
```

### Astroid collision

```
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack();
        for (int ast: asteroids) {
            collision: {
                while (!stack.isEmpty() && ast < 0 && 0 < stack.peek()) {
                    if (stack.peek() < -ast) {
                        stack.pop();
                        continue;
                    } else if (stack.peek() == -ast) {
                        stack.pop();
                    }
                    break collision;
                }
                stack.push(ast);
            }
        }

        int[] ans = new int[stack.size()];
        for (int t = ans.length - 1; t >= 0; --t) {
            ans[t] = stack.pop();
        }
        return ans;
    }
}
```



### Word Break

https://leetcode.com/problems/word-break/

```
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```



### Word Ladder

https://leetcode.com/problems/word-ladder/

```
class Solution {
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> set = new HashSet<>(wordList);
    Queue<String> queue = new LinkedList<>();
    queue.add(beginWord);
    // COUNT NUMBER OF WORDS TRANSFORMED
    int count = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        // FOR ALL WORDS THIS ROUND
        for (int i = 0; i < size; i++) {
            char[] current = queue.poll().toCharArray();
            // TRAVERSE CURRENT WORD
            for (int j = 0; j < current.length; j++) {
                char tmp = current[j];
                // CHANGE ONE LETTER AT A TIME 
                for (char c = 'a'; c <= 'z'; c++) {
                    current[j] = c;
                    String next = new String(current);
                    // WHEN NEXT WORD IS IN THE SET
                    if (set.contains(next)) {
                        if (next.equals(endWord)) return count + 1;
                        queue.add(next);
                        set.remove(next);
                    }
                }
                // HAVE TO UNDO FOR NEXT CHANGE OF LETTER
                current[j] = tmp;
            }
        }
        // THIS ROUND ENDS WITH ONE LETTER CHANGED
        count++;
    }
    return 0;
}
}
```



### Word Search II

https://leetcode.com/problems/word-search-ii/

```
class TrieNode {
  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
  String word = null;
  public TrieNode() {}
}

class Solution {
  char[][] _board = null;
  ArrayList<String> _result = new ArrayList<String>();

  public List<String> findWords(char[][] board, String[] words) {

    // Step 1). Construct the Trie
    TrieNode root = new TrieNode();
    for (String word : words) {
      TrieNode node = root;

      for (Character letter : word.toCharArray()) {
        if (node.children.containsKey(letter)) {
          node = node.children.get(letter);
        } else {
          TrieNode newNode = new TrieNode();
          node.children.put(letter, newNode);
          node = newNode;
        }
      }
      node.word = word;  // store words in Trie
    }

    this._board = board;
    // Step 2). Backtracking starting for each cell in the board
    for (int row = 0; row < board.length; ++row) {
      for (int col = 0; col < board[row].length; ++col) {
        if (root.children.containsKey(board[row][col])) {
          backtracking(row, col, root);
        }
      }
    }

    return this._result;
  }
  
  private void backtracking(int row, int col, TrieNode parent) {
    Character letter = this._board[row][col];
    TrieNode currNode = parent.children.get(letter);

    // check if there is any match
    if (currNode.word != null) {
      this._result.add(currNode.word);
      currNode.word = null;
    }

    // mark the current letter before the EXPLORATION
    this._board[row][col] = '#';

    // explore neighbor cells in around-clock directions: up, right, down, left
    int[] rowOffset = {-1, 0, 1, 0};
    int[] colOffset = {0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
      int newRow = row + rowOffset[i];
      int newCol = col + colOffset[i];
      if (newRow < 0 || newRow >= this._board.length || newCol < 0
          || newCol >= this._board[0].length) {
        continue;
      }
      if (currNode.children.containsKey(this._board[newRow][newCol])) {
        backtracking(newRow, newCol, currNode);
      }
    }

    // End of EXPLORATION, restore the original letter in the board.
    this._board[row][col] = letter;

    // Optimization: incrementally remove the leaf nodes
    if (currNode.children.isEmpty()) {
      parent.children.remove(letter);
    }
  }
}

```

### Min Stack

```
class MinStack {

    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();
    
    
    public MinStack() { }
    
    
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        }
    }
    
    
    public void pop() {
        if (stack.peek().equals(minStack.peek())) {
            minStack.pop();
        }
        stack.pop();
    }
    
    
    public int top() {
        return stack.peek();
    }

    
    public int getMin() {
        return minStack.peek();
    }
}
```



Analyze User Website Visit Pattern
https://leetcode.com/problems/analyze-user-website-visit-pattern/

Fraction to Recurring Decimal
https://leetcode.com/problems/fraction-to-recurring-decimal/

Letter Combinations of a Phone Number
https://leetcode.com/problems/le ... -of-a-phone-number/

Evaluate Reverse Polish Notation
https://leetcode.com/problems/evaluate-reverse-polish-notation/
如何用generator遍历一个很大的二叉树。

K Closest Points to Origin
https://leetcode.com/problems/k-closest-points-to-origin/

Top K Frequent Elements
https://leetcode.com/problems/top-k-frequent-elements/

Smallest Range II
https://leetcode.com/problems/smallest-range-ii/

Generate Parentheses
https://leetcode.com/problems/generate-parentheses/

Design Tic-Tac-Toe
https://leetcode.com/problems/design-tic-tac-toe/



### Popcount

```
public class Solution {
    private int popCount(int x) {
        int count;
        for (count = 0; x != 0; ++count) {
            x &= x - 1; // zeroing out the least significant nonzero bit
            System.out.println(x);
        }
        System.out.println("<<<<<<<<<<<<<");
        System.out.println(count);
        return count;
    }

    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int x = 0; x <= n; ++x) {
            ans[x] = popCount(x);
            System.out.println("-----------");
        }
        return ans;
    }
}
```



### Counting Bits

https://leetcode.com/problems/counting-bits/

```
public class Solution {
    // you need to treat n as an unsigned value
public int hammingWeight(int n) {
    int bits = 0;
    int mask = 1;
    for (int i = 0; i < 32; i++) {
        if ((n & mask) != 0) {
            bits++;
        }
        mask <<= 1;
    }
    return bits;
}
}

public int hammingWeight(int n) {
    int sum = 0;
    while (n != 0) {
        sum++;
        n &= (n - 1);
    }
    return sum;
}
```



### Design in memory file system

```
public class FileSystem {
    class File {
        boolean isfile = false;
        HashMap < String, File > files = new HashMap < > ();
        String content = "";
    }
    File root;
    public FileSystem() {
        root = new File();
    }

    public List < String > ls(String path) {
        File t = root;
        List < String > files = new ArrayList < > ();
        if (!path.equals("/")) {
            String[] d = path.split("/");
            for (int i = 1; i < d.length; i++) {
                t = t.files.get(d[i]);
            }
            if (t.isfile) {
                files.add(d[d.length - 1]);
                return files;
            }
        }
        List < String > res_files = new ArrayList < > (t.files.keySet());
        Collections.sort(res_files);
        return res_files;
    }

    public void mkdir(String path) {
        File t = root;
        String[] d = path.split("/");
        for (int i = 1; i < d.length; i++) {
            if (!t.files.containsKey(d[i]))
                t.files.put(d[i], new File());
            t = t.files.get(d[i]);
        }
    }

    public void addContentToFile(String filePath, String content) {
        File t = root;
        String[] d = filePath.split("/");
        for (int i = 1; i < d.length - 1; i++) {
            t = t.files.get(d[i]);
        }
        if (!t.files.containsKey(d[d.length - 1]))
            t.files.put(d[d.length - 1], new File());
        t = t.files.get(d[d.length - 1]);
        t.isfile = true;
        t.content = t.content + content;
    }

    public String readContentFromFile(String filePath) {
        File t = root;
        String[] d = filePath.split("/");
        for (int i = 1; i < d.length - 1; i++) {
            t = t.files.get(d[i]);
        }
        return t.files.get(d[d.length - 1]).content;
    }
}

/**
 * Your FileSystem object will be instantiated and called as such:
 * FileSystem obj = new FileSystem();
 * List<String> param_1 = obj.ls(path);
 * obj.mkdir(path);
 * obj.addContentToFile(filePath,content);
 * String param_4 = obj.readContentFromFile(filePath);
 */
```



### Unique Paths II

https://leetcode.com/problems/unique-paths-ii/

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

        int R = obstacleGrid.length;
        int C = obstacleGrid[0].length;

        // If the starting cell has an obstacle, then simply return as there would be
        // no paths to the destination.
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        // Number of ways of reaching the starting cell = 1.
        obstacleGrid[0][0] = 1;

        // Filling the values for the first column
        for (int i = 1; i < R; i++) {
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }

        // Filling the values for the first row
        for (int i = 1; i < C; i++) {
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }

        // Starting from cell(1,1) fill up the values
        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]
        // i.e. From above and left.
        for (int i = 1; i < R; i++) {
            for (int j = 1; j < C; j++) {
                if (obstacleGrid[i][j] == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                } else {
                    obstacleGrid[i][j] = 0;
                }
            }
        }

        // Return value stored in rightmost bottommost cell. That is the destination.
        return obstacleGrid[R - 1][C - 1];
    }
}
```



### Trapping Rain Water

https://leetcode.com/problems/trapping-rain-water/

```
class Solution {
public:
int trap(vector<int>& height)
{
    if(height.empty())
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
};
```

### Fruit Into Baskets

https://leetcode.com/problems/fruit-into-baskets/

```
public int totalFruit(int[] fruits) {
    int maxLen=0; int i=0,j=0;
    HashMap<Integer,Integer> h=new HashMap<>();

    while(j<fruits.length)
    {
        h.put(fruits[j],h.getOrDefault(fruits[j],0)+1);
        while(h.size()>2)
        {
            h.put(fruits[i],h.get(fruits[i])-1);
            if(h.get(fruits[i])==0)
                h.remove(fruits[i]);
            i++;
        }
        maxLen=Math.max(maxLen, j-i+1);
        j++;
    }
    return maxLen;
}
```



### Serialize and Deserialize Binary Tree

https://leetcode.com/problems/se ... ialize-binary-tree/

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
      public String rserialize(TreeNode root, String str) {
    // Recursive serialization.
    if (root == null) {
      str += "null,";
    } else {
      str += str.valueOf(root.val) + ",";
      str = rserialize(root.left, str);
      str = rserialize(root.right, str);
    }
    return str;
  }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
         return rserialize(root, "");
    }

   public TreeNode rdeserialize(List<String> l) {
    // Recursive deserialization.
    if (l.get(0).equals("null")) {
      l.remove(0);
      return null;
    }

    TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));
    l.remove(0);
    root.left = rdeserialize(l);
    root.right = rdeserialize(l);

    return root;
  }
    
    
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
            String[] data_array = data.split(",");
    List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));
    return rdeserialize(data_list);
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



### Climbing Stairs

https://leetcode.com/problems/climbing-stairs/

```
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] > 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
```



### Subarray Sum Equals K

https://leetcode.com/problems/subarray-sum-equals-k/

```
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, sum = 0;
        HashMap < Integer, Integer > map = new HashMap < > ();
        map.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (map.containsKey(sum - k))
                count += map.get(sum - k);
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return count;
    }
}
```



### Binary Tree Zigzag Level Order Traversal

https://leetcode.com/problems/bi ... el-order-traversal/

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */



     1
   3     7
 4   5   6  8
      
class Solution {
  protected void DFS(TreeNode node, int level, List<List<Integer>> results) {
     if(node == null) return;
    if (level >= results.size()) {
      LinkedList<Integer> newLevel = new LinkedList<Integer>();
      newLevel.add(node.val);
      results.add(newLevel);
    } else {
      if (level % 2 == 0)
        results.get(level).add(node.val);
      else
        results.get(level).add(0, node.val);
    }

    DFS(node.left, level + 1, results);
    DFS(node.right, level + 1, results);
  }

  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    if (root == null) {
      return new ArrayList<List<Integer>>();
    }
    List<List<Integer>> results = new ArrayList<List<Integer>>();
    DFS(root, 0, results);
    return results;
  }
}
```



### Jump Game

https://leetcode.com/problems/jump-game/

```
public class Solution {
    enum Index {
    GOOD, BAD, UNKNOWN
}
    Index[] memo;
    
    
    public boolean canJumpFromPosition(int position, int[] nums) {

        if (memo[position] != Index.UNKNOWN) {
            return memo[position] == Index.GOOD ? true : false;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {

            if (canJumpFromPosition(nextPosition, nums)) {
                memo[position] = Index.GOOD;
                return true;
            }
        }
        memo[position] = Index.BAD;

        return false;
    }

    public boolean canJump(int[] nums) {
          memo = new Index[nums.length];
        for (int i = 0; i < memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        
        return canJumpFromPosition(0, nums);
    }
}
```



### Decode String

https://leetcode.com/problems/decode-string/

```
class Solution {
    public String decodeString(String s) {
      Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ']') {
                List<Character> decodedString = new ArrayList<>();
                // get the encoded string
                while (stack.peek() != '[') {
                    decodedString.add(stack.pop());
                }
                // pop [ from the stack
                stack.pop();
                int base = 1;
                int k = 0;
                // get the number k
                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {
                    k = k + (stack.pop() - '0') * base;
                    base *= 10;
                }
                // decode k[decodedString], by pushing decodedString k times into stack
                while (k != 0) {
                    for (int j = decodedString.size() - 1; j >= 0; j--) {
                        stack.push(decodedString.get(j));
                    }
                    k--;
                }
            }
            // push the current character to stack
            else {
                stack.push(s.charAt(i));
            }
        }      
        // get the result from stack
        char[] result = new char[stack.size()];
        for (int i = result.length - 1; i >= 0; i--) {
            result[i] = stack.pop();
        }
        return new String(result);
    }
}
```



### Find Peak Element

https://leetcode.com/problems/find-peak-element/

```
public class Solution {
    public int findPeakElement(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i + 1])
                return i;
        }
        return nums.length - 1;
    }
}
```

### 给个整数n，找到从1到n的prime num。

```
// Java program to display
// Prime numbers till N
class GFG
{
//function to check if a given number is prime
static boolean isPrime(int n){
//since 0 and 1 is not prime return false.
if(n==1||n==0)return false;

//Run a loop from 2 to square root of n
for(int i=2; i*i<=n; i++){
	// if the number is divisible by i, then n is not a prime number.
	if(n%i==0)return false;
}
//otherwise, n is prime number.
return true;
}
	

// Driver code
public static void main (String[] args)
{
	int N = 100;
		//check for every number from 1 to N
	for(int i=1; i<=N; i++){
	//check if current number is prime
	if(isPrime(i)) {
		System.out.print(i + " ");
	}
	}
	
}
}

```

Standard amazonian level, SDE1, 2, 3 

Resoposible ownership, develop, deploy

### Basic Calculator

https://leetcode.com/problems/basic-calculator/

```
stack
class Solution {
    public int calculate(String s) {

        Stack<Integer> stack = new Stack<Integer>();
        int operand = 0;
        int result = 0; // For the on-going result
        int sign = 1;  // 1 means positive, -1 means negative

        for (int i = 0; i < s.length(); i++) {

            char ch = s.charAt(i);
            if (Character.isDigit(ch)) {

                // Forming operand, since it could be more than one digit
                operand = 10 * operand + (int) (ch - '0');

            } else if (ch == '+') {

                // Evaluate the expression to the left,
                // with result, sign, operand
                result += sign * operand;

                // Save the recently encountered '+' sign
                sign = 1;

                // Reset operand
                operand = 0;

            } else if (ch == '-') {

                result += sign * operand;
                sign = -1;
                operand = 0;

            } else if (ch == '(') {

                // Push the result and sign on to the stack, for later
                // We push the result first, then sign
                stack.push(result);
                stack.push(sign);

                // Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1;
                result = 0;

            } else if (ch == ')') {

                // Evaluate the expression to the left
                // with result, sign and operand
                result += sign * operand;

                // ')' marks end of expression within a set of parenthesis
                // Its result is multiplied with sign on top of stack
                // as stack.pop() is the sign before the parenthesis
                result *= stack.pop();

                // Then add to the next operand on the top.
                // as stack.pop() is the result calculated before this parenthesis
                // (operand on stack) + (sign on stack * (result from parenthesis))
                result += stack.pop();

                // Reset the operand
                operand = 0;
            }
        }
        return result + (sign * operand);
    }
}
```



### Longest String Chain

https://leetcode.com/problems/longest-string-chain/

```

class Solution {

    private int dfs(Set<String> words, Map<String, Integer> memo, String currentWord) {
        // If the word is encountered previously we just return its value present in the map (memoization).
        if (memo.containsKey(currentWord)) {
            return memo.get(currentWord);
        }
        // This stores the maximum length of word sequence possible with the 'currentWord' as the
        int maxLength = 1;
        StringBuilder sb = new StringBuilder(currentWord);

        // creating all possible strings taking out one character at a time from the `currentWord`
        for (int i = 0; i < currentWord.length(); i++) {
            sb.deleteCharAt(i);
            String newWord = sb.toString();
            // If the new word formed is present in the list, we do a dfs search with this newWord.
            if (words.contains(newWord)) {
                int currentLength = 1 + dfs(words, memo, newWord);
                maxLength = Math.max(maxLength, currentLength);
            }
            sb.insert(i, currentWord.charAt(i));
        }
        memo.put(currentWord, maxLength);

        return maxLength;
    }

    public int longestStrChain(String[] words) {
        Map<String, Integer> memo = new HashMap<>();
        Set<String> wordsPresent = new HashSet<>();
        Collections.addAll(wordsPresent, words);
        int ans = 0;
        for (String word : words) {
            ans = Math.max(ans, dfs(wordsPresent, memo, word));
        }
        return ans;
    }
}

```



### Insertion Sort List

https://leetcode.com/problems/insertion-sort-list/

```
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode();
        ListNode curr = head;

        while (curr != null) {
            // At each iteration, we insert an element into the resulting list.
            ListNode prev = dummy;

            // find the position to insert the current node
            while (prev.next != null && prev.next.val < curr.val) {
                prev = prev.next;
            }

            ListNode next = curr.next;
            // insert the current node to the new list
            
            # Before cur: 4 -> 3 -> 2 -> 1
            curr.next = prev.next;
            # After cur: 4 -> null
            
            # Before pre: 0 -> null
            prev.next = curr;
            # After prev: 0 -> 4 -> null

            // moving on to the next iteration
            curr = next;
        }

        return dummy.next;
    }
}
```



### Valid Parenthesis String

https://leetcode.com/problems/valid-parenthesis-string/

![image-20220621095454774](C:\Users\48965\OneDrive\桌面\面试\pictures\image-20220621095454774.png)see below

### Group Anagrams

https://leetcode.com/problems/group-anagrams/

```
        
        Map<String , List<String>> result = new HashMap<>();
        for(String str : strs){
            int [] array = new int [26];
            for(char c : str.toCharArray()){
                array[c - 'a'] += 1;
            }
            
            String key = Arrays.toString(array);
            
            if(result.get(key) == null){
                List<String> newList = new ArrayList<>();
                newList.add(str);
                result.put(key, newList);
            } else {
                List<String> temp = result.get(key);
                temp.add(str);
                result.put(key, temp);
            }
            
        }
        
        List<List<String>> finalResult = new ArrayList<>();
        
        for(String  i : result.keySet()){
            finalResult.add(result.get(i));
        }
        
        return finalResult;
    }
    // convert key to int array
```



### Integer Break

https://leetcode.com/problems/integer-break/

```
public int integerBreak(int n) {
       int[] dp = new int[n + 1];
       dp[1] = 1;
       for(int i = 2; i <= n; i ++) {
           for(int j = 1; j < i; j ++) {
               dp[i] = Math.max(dp[i], (Math.max(j,dp[j])) * (Math.max(i - j, dp[i - j])));
           }
       }
       return dp[n];
    }
    
    //Back track timeout
    class Solution {
    
    int maxInt = Integer.MIN_VALUE;
    Map<Integer,Integer> mem = new HashMap<>();
    int target = 0;
    public int integerBreak(int n) {
        target = n;
        backTrack(n,1);
        return maxInt;
    }
    
    
    List<Integer> toList(int n){
        List<Integer> res = new ArrayList<>();
        if(n == 2){
            res.add(1);
            return res;
        }
        for(int i = 1; i < n; i++){
            res.add(i);
        }
        return res;
    }

    public void backTrack(int n, int existingProd){
  
        if(n == 1 || n == 0){
     
            maxInt = Math.max(maxInt, existingProd);
            return ;
        }
        
      List<Integer> list = toList(n);
        if(n < target){
            list.add(n);
        }
        for(int breakDownInt : list){
    
            backTrack(n - breakDownInt, existingProd * breakDownInt);

        }

    }
}
```



### Implement Stack using Queues

https://leetcode.com/problems/implement-stack-using-queues/
find the nth node from the end of linked list

```
    public void push(int x) {
        q1.add(x);
        top = x;
    }
    
    public int pop() {
        Integer temp;
        while(q1.size() > 1){
            temp = q1.remove();
            top = temp;
            q2.add(temp);
        }
        int result = q1.remove();
       
        q1 = q2;
        q2 = new LinkedList<>();
        return result;
        
    }
    
    public int top() {
        return top;
    }
    
    public boolean empty() {
        return q1.isEmpty();
    }
```



678



返回二叉树的俯视图top view





### OOD

电梯
Traffic Through City
https://leetcode.com/discuss/int ... traffic-Through-City
Design finding box to fit in AMZ Locker
https://leetcode.com/discuss/int ... eedback-is-welcomed
design data types for Amazon locker and packages
Requirement: Design an optimized algorithm to fit the package in the right locker
有三种size的locker，每种大小各10个
Shopping cart
Linux file find/search API
设计停车场
https://leetcode.com/discuss/int ... ign-Using-OO-Design
Vending machine
https://leetcode.com/discuss/int ... level-Deign-orSDE-2
Design food delivery system
Design food ordering sy‍‌‌‌‍‌‍‌‌‍‌‌‍‍‌‍‌‌‍‍stem
https://leetcode.com/discuss/int ... ood-delivery-system

API Rate Limiter
https://leetcode.com/discuss/int ... 95/API-Rate-Limiter
Coffee maker
https://leetcode.com/discuss/int ... gn-a-Coffee-Machine
设计一个hit/visit counter
Key Value Storage
设计一个类似redis的key value storage，每个key都有对应的ttl，到期要删除。听面试官的提示他好像是想要有个thread在background不断检查然后删。感觉应该是要threading 跟 time, 但我当时不知道怎么写，就写了个检查的函数跟他说把这个传进去...
设计家庭温控器

System Design
Shorten url
url shortener
Rate Limiter
HM面的rate limitor. 让写出API, 从single server到large scale的设计，然后问到数据如何同步
design 1: rate limiter
Auto completion
sys design口述前缀树自动完成搜索栏，没画图都，完全口述。
system design题，设计一个类似google的query auto completion。
Instagram
(create post, follow users, get feeds)
Notification system
system desig‍‍‌‍‍‍‍‌‍‌‍‍‌‍‍‍‍‌‌n notification system
sd 设计一个notification 系统
大概就是design一个notification system, 会有一些相应的改动, 为了fit亚麻的project吧, 留的时间有点不太够加上我本来面SD就很弱, clarify requirement感觉用了太久, 可能显出来不够专业我感觉, 整体high level的内容倒是都聊出来了, 自己share screen找了一个online的white board..
Logging system
系统设计：
设计一个Log系统，要求能存储，并读取亚麻所有Application team的log
规模在100QPS
数据库的选用
从application到数据库
用户读取数据库
提取数据的api
第一轮: 大老板，System design，要设计他们组现在在用的系统，其他没啥，就是需要处理一些大的log... 我只用了DB+S3，但是老板希望我能使用elastic search，因为没有这方面经验直接跪
设计一个log collector。感觉面试官对这部分要求比较低
Amazon Product Review
sd：实现亚麻app里面的view order功能，用户点击view order以后显示最近50个order的product，timestamp，stat‍‌‌‌‍‌‍‌‌‍‌‌‍‍‌‍‌‌‍‍us。考虑高并发高可用，latency 200ms以下
Upload File
design: upload file -> deliver to multiple regions
航站楼的登记系统
第一轮系统设计， 让你设计一个去航站楼的登记系统
要求：
1： 乘客要能登入
2：选择座位
3：打印机票
我的想法是 建立两个service， 一个是check in, 一个是seat selection
check in service 连一个DB， Seat 连一个DB
check in  table primary key confirmation， 然后存一大推乘客信息。 这里我觉得没有必要乘客单独弄一个表，做飞机的时候 名字对上就行了
seat 的table 就麻烦一点， 一开始也想用个sql 因为这个系统query不会很多 感觉没必要用NOSQL。
但是后来发现不好弄， 就改成了 key value store, 其实应该说wide column 更恰当， 就是用flight ID 作为key， 然后value 再嵌套一个 key value pair， 这样不同的key 可以放座位ID ，value就是名字/或者 用户的ID。 不同飞机大小都可以放在这个表里面
然后说到这里， 面试官也没说什么。 然后就问了 怎么操作这个 seat selection， 我就说 需要两个request， 一个是读， 一个是写
读是 拿到飞机的信息，选好之后你要写回去。
这显然就有打架的问题， 两个人都选了一个位置怎么办。 我就说加锁 在数据库 这边。 其实也可以compareand swap 面试的时候紧张 没说。
最后问数据坏了怎么办， 那就是多点service， 多个database 做replica 候着。
不知道其他朋友有没有什么高见。
设计亚马逊SQS
Monitoring system
设置分布式 metrics 监控系统
Library management system
Design Bookstore
component design/system design，这两个都是bookstore的design
Alex interaction history
system design 设计一个Alex interaction history
Paking lot
停车场泊车/取车问题
Conference reservation system
coding问了如何design一个conference reservation system。
需求是：给一个start 和end time，room size，location 返回一个合适大小并且距离最近的空房间。
Real time sensor network
sd是要做一个real time sensor network，数量1m，10s一更。主要关注的是如果network有de‍‌‌‌‍‌‍‌‌‍‌‌‍‍‌‍‌‌‍‍lay，大量信息同时传过来要怎么办。
Online multi-user play game
Design：全程唠嗑。前端需要从后端拿数据来显示页面，现在需要设计一个系统来保证即便后端的服务器宕机了，前端依旧能拿到数据来显示页面，数据可以是之前显示过得。有很多followup，从数据库怎么选择，数据库数据如果因为bu‍‌‌‌‍‌‍‌‌‍‌‌‍‍‌‍‌‌‍‍g不对了怎么办，数据库处理能力有限，但请求很多怎么处理。。。
亚马逊快递司机的追踪系统
设计一个亚马逊快递司机的追踪系统 每10s有100万个司机的地理位置信息传回给系统里 / 每200个司机有1个op mgr 会打开网页查看这200个司机是不是比预计的时间迟了 / 终端用户不会经常刷新司机的位置 但系统要推送提示给用户。
设计个stackoverflow
让设计个stackoverflow，先头脑风暴让你说一些它里面的功能，然后网上白板画各种class和api还有彼此的关系
设计aws rds
最后，求大米啊求大米



Binary Tree

### Preorder + PostOrder

[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal)

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        return constructFromPrePost(pre, 0, pre.length - 1, post, 0, pre.length - 1);
    }
    
    private TreeNode constructFromPrePost(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {
        // Base cases.
        if (preStart > preEnd) {
            return null;
        }
        if (preStart == preEnd) {
            return new TreeNode(pre[preStart]);
        }
        
        // Build root.
        TreeNode root = new TreeNode(pre[preStart]);
        
        // Locate left subtree.
        int leftSubRootInPre = preStart + 1; 
        int leftSubRootInPost = findLeftSubRootInPost(pre[leftSubRootInPre], post, postStart, postEnd);
        int leftSubEndInPre = leftSubRootInPre + (leftSubRootInPost - postStart);
        
        // Divide.
        TreeNode leftSubRoot = constructFromPrePost(pre, leftSubRootInPre, leftSubEndInPre, 
                                                    post, postStart, leftSubRootInPost);  
        TreeNode rightSubRoot = constructFromPrePost(pre, leftSubEndInPre + 1, preEnd, 
                                                     post, leftSubRootInPost + 1, postEnd - 1);
        
        // Conquer.      
        root.left = leftSubRoot;
        root.right = rightSubRoot;
        
        return root;
    }
    
    private int findLeftSubRootInPost(int leftSubRootVal, int[] post, int postStart, int postEnd) {
        for (int i = postStart; i <= postEnd; i++) {
            if (post[i] == leftSubRootVal) {
                return i;
            }
        }
        
        throw new IllegalArgumentException();
    }
}
             1
         2       3
       4     5  6   7

Based on pre order
     
Pre

1 (2,4,5) (3,6,7)


Post 
(4,5,2)  (6,7,3 ) 1

```



### InOrder + PostOrder



```
class Solution {
  int post_idx;
  int[] postorder;
  int[] inorder;
  HashMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();

  public TreeNode helper(int in_left, int in_right) {
    // if there is no elements to construct subtrees
    if (in_left > in_right)
      return null;

    // pick up post_idx element as a root
    int root_val = postorder[post_idx];
    TreeNode root = new TreeNode(root_val);

    // root splits inorder list
    // into left and right subtrees
    int index = idx_map.get(root_val);

    // recursion 
    post_idx--;
    // build right subtree
    root.right = helper(index + 1, in_right);
    // build left subtree
    root.left = helper(in_left, index - 1);
    return root;
  }

  public TreeNode buildTree(int[] inorder, int[] postorder) {
    this.postorder = postorder;
    this.inorder = inorder;
    // start from the last postorder element
    post_idx = postorder.length - 1;

    // build a hashmap value -> its index
    int idx = 0;
    for (Integer val : inorder)
      idx_map.put(val, idx++);
    return helper(0, inorder.length - 1);
  }
}
             1
         2       3
       4     5  6   7
     8   9
                 
                 
(8 4 9 2 5)   1  ( (6)   3   (7))
(8 9 4 5 2)  (6   7   3)  1
                 
Based on In order

(2 9 4)  3 (15 20 7)
    
    
(2 4 9)  (15 7 20) 3
    
  
    
```

### PreOrder + InOrder

```
preorder = [3,9,20,15,7], inorder = [(9 ) 3 (15,20,7)]


class Solution {
    int preorderIndex;
    Map<Integer, Integer> inorderIndexMap;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        preorderIndex = 0;
        // build a hashmap to store value -> its index relations
        inorderIndexMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderIndexMap.put(inorder[i], i);
        }

        return arrayToTree(preorder, 0, preorder.length - 1);
    }

    private TreeNode arrayToTree(int[] preorder, int left, int right) {
        // if there are no elements to construct the tree
        if (left > right) return null;

        // select the preorder_index element as the root and increment it
        int rootValue = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootValue);

        // build left and right subtree
        // excluding inorderIndexMap[rootValue] element because it's the root
        root.left = arrayToTree(preorder, left, inorderIndexMap.get(rootValue) - 1);
        root.right = arrayToTree(preorder, inorderIndexMap.get(rootValue) + 1, right);
        return root;
    }
}
```

### Recover binary tree

```
  public void inorder(TreeNode root, List<Integer> nums) {
    if (root == null) return;
    inorder(root.left, nums);
    nums.add(root.val);
    inorder(root.right, nums);
  }

  public int[] findTwoSwapped(List<Integer> nums) {
    int n = nums.size();
    int x = -1, y = -1;
    boolean swapped_first_occurrence = false;
    for(int i = 0; i < n - 1; ++i) {
      if (nums.get(i + 1) < nums.get(i)) {
        y = nums.get(i + 1);
        if (!swapped_first_occurrence) {
            // first swap occurrence
            x = nums.get(i);
            swapped_first_occurrence = true;
        } else {
            // second swap occurrence
            break;
        }
      }
    }
    return new int[]{x, y};
  }

  public void recover(TreeNode r, int count, int x, int y) {
    if (r != null) {
      if (r.val == x || r.val == y) {
        r.val = r.val == x ? y : x;
        if (--count == 0) return;
      }
      recover(r.left, count, x, y);
      recover(r.right, count, x, y);
    }
  }

  public void recoverTree(TreeNode root) {
    List<Integer> nums = new ArrayList();
    inorder(root, nums);
    int[] swapped = findTwoSwapped(nums);
    recover(root, 2, swapped[0], swapped[1]);
  }
```

